"""
VoronoiStorage - Query library for voronoi_precomputed table.

This module provides read-only access to the voronoi data generated by
compute_voronoi_unified.py. It's used by the API to serve voronoi nodes
to the frontend.

Note: Write operations (add_node, flush, etc.) are embedded in
compute_voronoi_unified.py and not exposed here.
"""

import json
import logging
from datetime import date
from typing import Any, Dict, List, Optional

from clickhouse_driver import Client

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("VoronoiStorage")


class VoronoiStorage:
    """
    Read-only interface to filesystem.voronoi_precomputed table.

    Used by FastAPI to serve individual voronoi nodes for incremental loading.
    """

    TABLE_NAME = "filesystem.voronoi_precomputed"

    def __init__(
        self,
        host: str = "localhost",
        port: int = 9000,
        user: str = "default",
        password: str = "",
        database: str = "filesystem",
        batch_size: int = 1000,  # Unused for queries, kept for compatibility
    ):
        """
        Initialize voronoi storage client.

        Args:
            host: ClickHouse host
            port: ClickHouse port
            user: ClickHouse user
            password: ClickHouse password
            database: ClickHouse database
            batch_size: Ignored (kept for API compatibility)
        """
        self.host = host
        self.port = port
        self.user = user
        self.password = password
        self.database = database

    def _get_client(self) -> Client:
        """Create a ClickHouse client connection."""
        return Client(
            host=self.host,
            port=self.port,
            user=self.user,
            password=self.password,
            database=self.database,
        )

    def get_node(
        self, snapshot_date: date, node_id: str
    ) -> Optional[Dict[str, Any]]:
        """
        Retrieve a single node by snapshot_date and node_id.

        Args:
            snapshot_date: Snapshot date
            node_id: Node ID to retrieve

        Returns:
            Node data as dict with keys:
            - node_id, parent_id, path, name, size, depth
            - is_directory, file_count, children_ids
            - is_synthetic, original_files (if synthetic)
            Or None if not found
        """
        query = f"""
        SELECT
            node_id, parent_id, path, name, size, depth,
            is_directory, file_count, children_json,
            is_synthetic, original_files_json
        FROM {self.TABLE_NAME}
        WHERE snapshot_date = %(snapshot_date)s
          AND node_id = %(node_id)s
        LIMIT 1
        """

        try:
            client = self._get_client()
            result = client.execute(
                query,
                {
                    "snapshot_date": snapshot_date.isoformat(),
                    "node_id": node_id,
                },
            )
            client.disconnect()

            if not result or len(result) == 0:
                return None

            row = result[0]
            (
                node_id_val,
                parent_id,
                path,
                name,
                size,
                depth,
                is_directory,
                file_count,
                children_json,
                is_synthetic,
                original_files_json,
            ) = row

            # Parse JSON fields
            children_ids = json.loads(children_json) if children_json else []
            original_files = (
                json.loads(original_files_json) if original_files_json else []
            )

            return {
                "node_id": node_id_val,
                "parent_id": parent_id,
                "path": path,
                "name": name,
                "size": size,
                "depth": depth,
                "is_directory": is_directory,
                "file_count": file_count,
                "children_ids": children_ids,
                "is_synthetic": is_synthetic,
                "original_files": original_files,
            }

        except Exception as e:
            logger.error(
                f"Failed to retrieve node {node_id} for snapshot {snapshot_date}: {e}"
            )
            return None

    def get_root_node_id(
        self, snapshot_date: date, root_path: str = "/project/cil"
    ) -> Optional[str]:
        """
        Get the root node ID for a snapshot by path.

        Note: The unified script computes depth as path.count('/'), so
        we query by path instead of depth=0.

        Args:
            snapshot_date: Snapshot date
            root_path: Root path to query (default: /project/cil)

        Returns:
            Root node_id or None if not found
        """
        query = f"""
        SELECT node_id
        FROM {self.TABLE_NAME}
        WHERE snapshot_date = %(snapshot_date)s
          AND path = %(root_path)s
        LIMIT 1
        """

        try:
            client = self._get_client()
            result = client.execute(
                query,
                {
                    "snapshot_date": snapshot_date.isoformat(),
                    "root_path": root_path,
                },
            )
            client.disconnect()

            if result and len(result) > 0:
                return result[0][0]
            return None

        except Exception as e:
            logger.error(
                f"Failed to get root node for snapshot {snapshot_date}: {e}"
            )
            return None

    def get_node_by_path(
        self, snapshot_date: date, path: str
    ) -> Optional[Dict[str, Any]]:
        """
        Get a node by its path instead of node_id.

        This is useful for navigation when you only know the target path
        (from clicking a partition) but need to fetch the corresponding node.

        Args:
            snapshot_date: Snapshot date
            path: Full path to the node (e.g., "/project/cil/gcp")

        Returns:
            Node data dict or None if not found
        """
        query = f"""
        SELECT node_id
        FROM {self.TABLE_NAME}
        WHERE snapshot_date = %(snapshot_date)s
          AND path = %(path)s
        LIMIT 1
        """

        try:
            client = self._get_client()
            result = client.execute(
                query,
                {
                    "snapshot_date": snapshot_date.isoformat(),
                    "path": path,
                },
            )
            client.disconnect()

            if result and len(result) > 0:
                node_id = result[0][0]
                # Reuse get_node to fetch full node data
                return self.get_node(snapshot_date, node_id)
            return None

        except Exception as e:
            logger.error(
                f"Failed to get node by path {path} for snapshot {snapshot_date}: {e}"
            )
            return None

    def get_stats(self, snapshot_date: date) -> Optional[Dict[str, Any]]:
        """
        Get statistics for a snapshot's voronoi data.

        Args:
            snapshot_date: Snapshot date

        Returns:
            Stats dict with total_nodes, max_depth, total_size
        """
        query = f"""
        SELECT
            count() as total_nodes,
            max(depth) as max_depth,
            sum(size) as total_size
        FROM {self.TABLE_NAME}
        WHERE snapshot_date = %(snapshot_date)s
        """

        try:
            client = self._get_client()
            result = client.execute(
                query, {"snapshot_date": snapshot_date.isoformat()}
            )
            client.disconnect()

            if result and len(result) > 0:
                row = result[0]
                return {
                    "total_nodes": row[0],
                    "max_depth": row[1],
                    "total_size": row[2],
                }
            return None

        except Exception as e:
            logger.error(
                f"Failed to get stats for snapshot {snapshot_date}: {e}"
            )
            return None
